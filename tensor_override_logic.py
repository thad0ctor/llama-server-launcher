#!/usr/bin/env python3
"""
Tensor Override Logic Module for LLaMa.cpp Server Launcher
Handles integration of tensor override parameters with launcher configurations.
"""

import json
import os
import re
from pathlib import Path
from typing import List, Dict, Optional, Tuple


class TensorOverrideManager:
    """Manages tensor override parameters and configuration integration."""
    
    def __init__(self, tensor_override_dir: Optional[Path] = None):
        """
        Initialize tensor override manager.
        
        Args:
            tensor_override_dir: Directory for storing tensor override files
        """
        self.tensor_override_dir = tensor_override_dir or Path("tensor_overrides")
        self.tensor_override_dir.mkdir(exist_ok=True)
    
    def get_tensor_override_file_path(self, model_path: str, config_name: str) -> Path:
        """
        Get the expected path for tensor override parameters file.
        
        Args:
            model_path: Path to the model file
            config_name: Name of the configuration
            
        Returns:
            Path to the tensor override parameters file
        """
        model_name = Path(model_path).stem
        params_filename = f"{model_name}_{config_name}_tensor_params.txt"
        return self.tensor_override_dir / params_filename
    
    def has_tensor_override_params(self, model_path: str, config_name: str) -> bool:
        """
        Check if tensor override parameters exist for given model and config.
        
        Args:
            model_path: Path to the model file
            config_name: Name of the configuration
            
        Returns:
            True if parameters file exists and contains valid parameters
        """
        params_file = self.get_tensor_override_file_path(model_path, config_name)
        
        if not params_file.exists():
            return False
        
        try:
            params = self.load_tensor_override_params(model_path, config_name)
            return len(params) > 0
        except Exception:
            return False
    
    def load_tensor_override_params(self, model_path: str, config_name: str) -> List[str]:
        """
        Load tensor override parameters from file.
        
        Args:
            model_path: Path to the model file
            config_name: Name of the configuration
            
        Returns:
            List of tensor override parameter strings
        """
        params_file = self.get_tensor_override_file_path(model_path, config_name)
        
        if not params_file.exists():
            return []
        
        try:
            with open(params_file, 'r') as f:
                lines = f.readlines()
            
            # Extract parameter lines (starting with -ot)
            params = []
            for line in lines:
                line = line.strip()
                if line.startswith('-ot') and '\\' not in line:  # Skip continuation lines
                    params.append(line)
            
            return params
            
        except Exception as e:
            print(f"Error loading tensor override parameters: {e}")
            return []
    
    def save_tensor_override_params(self, model_path: str, config_name: str, 
                                   parameters: List[str], analysis_info: Optional[Dict] = None) -> bool:
        """
        Save tensor override parameters to file.
        
        Args:
            model_path: Path to the model file
            config_name: Name of the configuration
            parameters: List of parameter strings to save
            analysis_info: Optional analysis information to include in header
            
        Returns:
            True if saved successfully
        """
        params_file = self.get_tensor_override_file_path(model_path, config_name)
        
        try:
            with open(params_file, 'w') as f:
                # Write header
                model_name = Path(model_path).name
                f.write(f"# Tensor Override Parameters for {model_name}\n")
                f.write(f"# Configuration: {config_name}\n")
                f.write(f"# Generated by tensor-override optimizer\n")
                
                if analysis_info:
                    f.write(f"# Analysis Date: {analysis_info.get('timestamp', 'Unknown')}\n")
                    f.write(f"# Total Parameters: {len(parameters)}\n")
                
                f.write(f"# Use with llama.cpp server:\n\n")
                
                # Write parameters
                for param in parameters:
                    f.write(f"{param}\n")
            
            return True
            
        except Exception as e:
            print(f"Error saving tensor override parameters: {e}")
            return False
    
    def validate_tensor_override_params(self, parameters: List[str]) -> Tuple[bool, List[str]]:
        """
        Validate tensor override parameters format.
        
        Args:
            parameters: List of parameter strings to validate
            
        Returns:
            Tuple of (is_valid, list_of_issues)
        """
        issues = []
        
        if not parameters:
            issues.append("No parameters provided")
            return False, issues
        
        # Pattern for valid tensor override parameters
        # -ot <regex_pattern>=<device_spec> or -ot "<regex_pattern>=<device_spec>"
        # Support both quoted and unquoted patterns
        tensor_override_pattern = r'^-ot\s+(?:"[^"]*"|[^\s]+)=(?:CPU|CUDA\d+)(?:")?$'
        
        for i, param in enumerate(parameters):
            param = param.strip()
            
            if not param.startswith('-ot'):
                issues.append(f"Parameter {i+1}: Must start with '-ot'")
                continue
            
            if not re.match(tensor_override_pattern, param):
                issues.append(f"Parameter {i+1}: Invalid format - expected '-ot <pattern>=<device>' or '-ot \"<pattern>=<device>\"'")
                continue
            
            # Extract the pattern and device from the parameter
            # Handle both quoted and unquoted formats
            try:
                # Remove -ot prefix and whitespace
                param_content = param[3:].strip()
                
                # Check if it's quoted
                if param_content.startswith('"') and param_content.endswith('"'):
                    # Quoted format: -ot "pattern=device"
                    inner_content = param_content[1:-1]  # Remove quotes
                    parts = inner_content.split('=')
                else:
                    # Unquoted format: -ot pattern=device
                    parts = param_content.split('=')
                
                if len(parts) != 2:
                    issues.append(f"Parameter {i+1}: Must have exactly 2 parts separated by '=': pattern=device")
                    continue
                
                pattern = parts[0].strip()
                device = parts[1].strip()
                
                # Validate device
                if not (device == 'CPU' or re.match(r'^CUDA\d+$', device)):
                    issues.append(f"Parameter {i+1}: Invalid device '{device}' - must be 'CPU' or 'CUDAn'")
                    continue
                
                # Validate pattern (basic check for non-empty)
                if not pattern:
                    issues.append(f"Parameter {i+1}: Pattern cannot be empty")
                    continue
                    
            except Exception as e:
                issues.append(f"Parameter {i+1}: Error parsing parameter: {e}")
                continue
        
        return len(issues) == 0, issues
    
    def format_params_for_command_line(self, parameters: List[str]) -> List[str]:
        """
        Format tensor override parameters for command line usage.
        
        Args:
            parameters: List of parameter strings
            
        Returns:
            List of properly formatted command line arguments (split into -ot and pattern)
        """
        formatted = []
        
        for param in parameters:
            param = param.strip()
            if param and param.startswith('-ot'):
                # Split "-ot pattern=device" into ["-ot", "pattern=device"]
                # Handle both quoted and unquoted formats
                param_content = param[3:].strip()  # Remove "-ot" prefix
                
                # Remove outer quotes if present
                if param_content.startswith('"') and param_content.endswith('"'):
                    param_content = param_content[1:-1]
                
                # Add as separate arguments
                formatted.append('-ot')
                formatted.append(param_content)
        
        return formatted
    
    def get_tensor_override_summary(self, model_path: str, config_name: str) -> Dict:
        """
        Get summary information about tensor override configuration.
        
        Args:
            model_path: Path to the model file
            config_name: Name of the configuration
            
        Returns:
            Dictionary with summary information
        """
        params_file = self.get_tensor_override_file_path(model_path, config_name)
        
        summary = {
            'enabled': False,
            'parameters_file': str(params_file),
            'parameters_count': 0,
            'file_exists': params_file.exists(),
            'file_size_bytes': 0,
            'last_modified': None,
            'devices_used': [],
            'cpu_tensors': 0,
            'gpu_tensors': 0,
            'valid': False,
            'issues': []
        }
        
        if not params_file.exists():
            return summary
        
        try:
            # Get file stats
            stat = params_file.stat()
            summary['file_size_bytes'] = stat.st_size
            summary['last_modified'] = stat.st_mtime
            
            # Load and analyze parameters
            parameters = self.load_tensor_override_params(model_path, config_name)
            summary['parameters_count'] = len(parameters)
            
            if parameters:
                summary['enabled'] = True
                
                # Validate parameters
                is_valid, issues = self.validate_tensor_override_params(parameters)
                summary['valid'] = is_valid
                summary['issues'] = issues
                
                # Analyze device usage
                devices = set()
                cpu_count = 0
                gpu_count = 0
                
                for param in parameters:
                    param = param.strip()
                    if '=' in param:
                        parts = param.split('=')
                        if len(parts) == 2:
                            device = parts[1].strip()
                            devices.add(device)
                            
                            if device == 'CPU':
                                cpu_count += 1
                            elif device.startswith('CUDA'):
                                gpu_count += 1
                
                summary['devices_used'] = sorted(list(devices))
                summary['cpu_tensors'] = cpu_count
                summary['gpu_tensors'] = gpu_count
        
        except Exception as e:
            summary['issues'] = [f"Error analyzing file: {e}"]
        
        return summary
    
    def cleanup_old_tensor_files(self, keep_count: int = 10) -> int:
        """
        Clean up old tensor override files, keeping only the most recent ones.
        
        Args:
            keep_count: Number of files to keep per model/config combination
            
        Returns:
            Number of files deleted
        """
        deleted_count = 0
        
        try:
            # Get all tensor parameter files
            tensor_files = list(self.tensor_override_dir.glob("*_tensor_params.txt"))
            
            if len(tensor_files) <= keep_count:
                return 0  # Nothing to clean up
            
            # Group files by model/config (everything before _tensor_params.txt)
            file_groups = {}
            for file_path in tensor_files:
                # Extract base name (model_config part)
                base_name = file_path.name.replace('_tensor_params.txt', '')
                if base_name not in file_groups:
                    file_groups[base_name] = []
                file_groups[base_name].append(file_path)
            
            # Clean up each group
            for base_name, files in file_groups.items():
                if len(files) > keep_count:
                    # Sort by modification time (newest first)
                    files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
                    
                    # Delete oldest files
                    files_to_delete = files[keep_count:]
                    for file_path in files_to_delete:
                        try:
                            file_path.unlink()
                            deleted_count += 1
                        except Exception as e:
                            print(f"Error deleting {file_path}: {e}")
        
        except Exception as e:
            print(f"Error during cleanup: {e}")
        
        return deleted_count
    
    def export_tensor_config(self, model_path: str, config_name: str, 
                           export_path: Path) -> bool:
        """
        Export tensor override configuration to a standalone file.
        
        Args:
            model_path: Path to the model file
            config_name: Name of the configuration
            export_path: Path to export the configuration to
            
        Returns:
            True if exported successfully
        """
        try:
            parameters = self.load_tensor_override_params(model_path, config_name)
            summary = self.get_tensor_override_summary(model_path, config_name)
            
            export_data = {
                'model_path': model_path,
                'config_name': config_name,
                'summary': summary,
                'parameters': parameters,
                'export_timestamp': str(Path(model_path).stat().st_mtime),
                'launcher_version': '1.0'
            }
            
            with open(export_path, 'w') as f:
                json.dump(export_data, f, indent=2)
            
            return True
            
        except Exception as e:
            print(f"Error exporting tensor configuration: {e}")
            return False
    
    def import_tensor_config(self, import_path: Path, model_path: str, 
                           config_name: str) -> bool:
        """
        Import tensor override configuration from a standalone file.
        
        Args:
            import_path: Path to import the configuration from
            model_path: Target model path
            config_name: Target configuration name
            
        Returns:
            True if imported successfully
        """
        try:
            with open(import_path, 'r') as f:
                import_data = json.load(f)
            
            parameters = import_data.get('parameters', [])
            
            if not parameters:
                print("No parameters found in import file")
                return False
            
            # Validate parameters
            is_valid, issues = self.validate_tensor_override_params(parameters)
            if not is_valid:
                print(f"Invalid parameters in import file: {issues}")
                return False
            
            # Save to target location
            analysis_info = {
                'timestamp': import_data.get('export_timestamp', 'Unknown'),
                'imported_from': str(import_path),
                'original_model': import_data.get('model_path', 'Unknown'),
                'original_config': import_data.get('config_name', 'Unknown')
            }
            
            return self.save_tensor_override_params(
                model_path, config_name, parameters, analysis_info
            )
            
        except Exception as e:
            print(f"Error importing tensor configuration: {e}")
            return False